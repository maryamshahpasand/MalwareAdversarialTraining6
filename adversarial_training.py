import numpy as np
import sys
import psutil
import os
import csv
import torch
from torch.cuda import device

import load_data
from build_classifier import build_classifier , malware_classifier_net , train_target_model
# import GAN_sparce as GAN
import GAN
import GAN_nodataloader_2 as GAN_nodataloader
import retrain_classifier
import matplotlib.pyplot as plt

import hiddenlayer as h1


def cpuStats():
    print(sys.version)
    print(psutil.cpu_percent())
    print(psutil.virtual_memory())  # physical memory usage
    pid = os.getpid()
    py = psutil.Process(pid)
    memoryUse = py.memory_info()[0] / 2. ** 30  # memory use in GB...I think
    print('memory GB:', memoryUse)


use_cuda=True

if __name__ == '__main__':

    print("CUDA Available: ",torch.cuda.is_available())
    device = torch.device("cuda" if (use_cuda and torch.cuda.is_available()) else "cpu")

    results = []
    data_all , features= load_data.load_data(loaded= True)
    # data_all= load_data.load_data(loaded= True)
    mal_num = data_all[0][0].shape[0]
    ben_num = data_all[1][0].shape[0]
    hist = {}
    hist['0.1'] = []
    hist['0.2'] = []
    hist['0.3'] = []
    hist['0.4'] = []
    hist['0.5'] = []
    for por in [ 0.5]: #, 0.4 , 0.3 , 0.2 ,0.1  ]:
        if por>0:
            porr = int(mal_num / por - mal_num)
        else:
            porr = ben_num-1
        print(
            'number of malware for training = {0}\n'
            'number of benign for training= {1}\n'
            'Malware portion  = {2}\n'
                .format(mal_num,
                        porr, por ))

        data_original = [#(xmal, ymal)
                data_all[0] ,
                #(xben,yben )
                (data_all[1][0][0:porr] ,data_all[1][1][0:porr]),
                #(xtsmal, xtsben)
                (data_all[2][0],data_all[2][1][0:int((data_all[1][0][0:porr] .shape[0])*(0.3/0.7))]) ,#portion of train to test
                # (ytsmal, ytsben)
                (data_all[3][0] , data_all[3][1][0:int((data_all[1][0][0:porr] .shape[0])*(0.3/0.7))]) ]#portion of train to test
        data = [#(xmal, ymal)
                data_all[0] ,
                #(xben,yben )
                (data_all[1][0][0:porr] ,data_all[1][1][0:porr]),
                #(xtsmal, xtsben)
                (data_all[2][0],data_all[2][1][0:int((data_all[1][0][0:porr] .shape[0])*(0.3/0.7))]) ,#portion of train to test
                # (ytsmal, ytsben)
                (data_all[3][0] , data_all[3][1][0:int((data_all[1][0][0:porr] .shape[0])*(0.3/0.7))]) ]#portion of train to test
        plot_dist = []

        #change the type of generator whether you want its input to be malware and noise = 'Mal+Noise', or noise only ='Noise'
        GAN_ = GAN.GAN(input_size=data_original[0][0].shape[1], hidden_size=200, noise_size=100 , generator_type= 'Mal+Noise' ,losstype = 'limited_distortion')
       #  GAN_ = GAN_nodataloader.GAN(input_size=data_original[0][0].shape[1], hidden_size=200, noise_size=20 ,device=device)

        data_size = [(data_original[0][0]).shape[0]]
        # data_size = (data_original[0][0]).shape


        #Train the classifier
        # classifier_ = malware_classifier_net(data_original[0][0].shape[1], 200, 2).to(device)




        classifier_ , result_cls = build_classifier(type='RBF_SVM', data=data , train=True , por= str(por))
        # result_gan = GAN_.train(classifier_, epochs=10, data_original=data_original, batch_size=100, round=0 , por=por)

        # Train the GAN
        hist[str(por)] = GAN_.train(features, classifier_,device, epochs=50, data_original=data_original, batch_size=500 ,  )
       # hist[str(por)] = GAN_.train(features, classifier_, epochs=50, data_original=data_original, batch_size=500, round=0 , por=por )
        # hist[str(por)] = GAN_.train(classifier_, epochs=5, data_original=data_original, batch_size=100, round=0 , por=por )
        del GAN_


    Header = ['Round', 'Train_accuray', 'Test_accuray', 'Test_validationset_accuray' , 'Train_FNR', 'Test_FNR', 'Test_validationset_FNR' ,'Test_validationset_FPR' , 'cls_train_time' ,'MCR on train data' , 'MCR on test data' , 'gan_train_time']

    with open('/home/maryam/Code/python/adversarial_training/torch_impl/hist.csv', 'w', newline='') as outfile1:
        wr = csv.writer(outfile1, delimiter=',', quoting=csv.QUOTE_NONE)
        for key in hist:
            wr.writerow(hist[key])
        outfile1.close()
    x = range(len(hist['0.4']))

    y1 = hist['0.1']
    # y2 = hist['0.2']
    # y3 = hist['0.3']
    # y4 = hist['0.4']
    # y5 = hist['0.5']

    plt.plot(x, y1, label='0.1')
    # plt.plot(x, y2, label='0.2')
    # plt.plot(x, y3, label='0.3')
    # plt.plot(x, y4, label='0.4')
    # plt.plot(x, y5, label='0.5')

    plt.xlabel('Epoch')
    plt.ylabel('Attack Success Rate')

    plt.legend(loc=4)
    plt.grid(True)
    plt.tight_layout()
    plt.savefig('/home/maryam/Code/python/adversarial_training/torch_impl/train_hist.png')

    # results.append(np.concatenate([[0] , result_cls  ,  result_gan ]))
    for round in range(3):
        GAN_ = GAN.GAN(input_size=data_original[0][0].shape[1], hidden_size=300, noise_size=175 , generator_type='Mal' ,losstype = 'limited_distortion')
        result_cls , data  , distortion , classifier_= retrain_classifier.retrain_classifier(classifier_,data_size, GAN_, data=data, round=round , por= por )
        plot_dist.append(distortion)

        plt.figure()
        plt.boxplot(plot_dist, labels=[i for i in range(len(plot_dist))])

        # plt.show()
        plt.savefig('/home/maryam/Code/python/adversarial_training/torch_impl/_' + str(
            por) + '/new_adv_samples_distortion.png')

        plt.xlabel(
            'round of retraining(' + str(len(data[2][0])+len(data[2][1])) + ' adv. sample in each round is added to dataset)')
        plt.ylabel('distance from original version')
        del GAN_

        # change the type of generator whether you want its input to be malware and noise , or noise only
        GAN_ = GAN.GAN(input_size=data_original[0][0].shape[1], hidden_size=200, noise_size=175, generator_type='Noise' ,losstype = 'limited_distortion')
        # GAN_ = GAN.GAN(input_size=data_original[0][0].shape[1], hidden_size=200, noise_size=20)
        result_gan  = GAN_.train(features, classifier_, epochs=50, data_original=data_original, batch_size=100, round=round+1 , por=por)
        results.append(np.concatenate([[round+1] ,result_cls, result_gan]))

    Header = ['Round', 'Train_accuray', 'Test_accuray', 'Test_validationset_accuray' , 'Train_FNR', 'Test_FNR', 'Test_validationset_FNR' ,'Test_validationset_FPR' , 'cls_train_time' ,'MCR on train data' , 'MCR on test data' , 'gan_train_time']
    print("Writing data ...")
    with open('/home/maryam/Code/python/adversarial_training/torch_impl/_'+str(por)+'/results_.csv', 'w', newline='') as outfile1:
        wr = csv.writer(outfile1, delimiter=',', quoting=csv.QUOTE_NONE)
        wr.writerow([h for h in Header])
        for i in range(len(results)):
            wr.writerow(results[i])
        outfile1.close()
    #
